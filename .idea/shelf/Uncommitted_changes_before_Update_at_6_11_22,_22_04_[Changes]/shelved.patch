Index: src/PLAYER/MTS/Node.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package PLAYER.MTS;\n\nimport GAME.Cell;\nimport GAME.State;\nimport PLAYER.HumanPlayer;\nimport PLAYER.Player;\nimport PLAYER.RandomBot;\n\nimport java.util.ArrayList;\nimport java.util.Objects;\n\npublic class Node {\n    //TODO create the clone of the state all the time.\n\n    private Node parent;\n    private Node root;\n    private State state;\n    private ArrayList<Node> children;\n    private Cell white ;\n    private Cell black ;\n    private int depth;\n    private int numberOfSimulations;\n    private int numberOfWins;\n    private int numberOfChildren;\n    private ArrayList<Cell> emptyCells;\n\n    public Node(Node parent,State state,Cell white , Cell black){\n        this.parent = parent;\n        this.state = state;\n        this.white = white;\n        this.black = black;\n        try {\n            this.state = (State) (state.clone());\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        if(white != null) {\n            state.getBoard().getCells().get(white.getId()).setColor(0);\n            state.getBoard().getCells().get(black.getId()).setColor(1);\n            state.updatePlayerScores();\n        }\n        this.emptyCells = state.getBoard().getEmptyCells();\n        numberOfWins = 0;\n        numberOfChildren = 0;\n        numberOfSimulations = 0;\n        children = new ArrayList<>();\n    }\n\n    public boolean isRoot(){\n        return parent == null;\n    }\n    public Node addChild(Node child){\n        for (Node node: children) {\n            if(child.equals(node)){\n                return node;\n            }\n        }\n        children.add(child);\n        numberOfChildren++;\n        return child;\n    }\n\n    public Node getRandomChild(){\n        //TODO correct this method\n        if(children.size()==0)\n            return null;\n        return children.get((int)(Math.random()*children.size()));\n\n    }\n\n    public boolean terminalNode(){\n        return state.isGameOver();\n    }\n\n    public int numberOfPossibleMoves(){\n        int n = state.getBoard().getNumberOfEmptyCells();\n        int k = 2;\n        return factorial(n)/(factorial(n-k));\n    }\n\n    public boolean Do_I_Have_More_Moves(){\n        int n = state.getBoard().getNumberOfEmptyCells();\n        int k = n - 2;\n        int posibleMoves = factorial(n)/(2 * factorial(k));\n        if(posibleMoves <= numberOfChildren){\n            return false;\n        }\n        return true;\n    }\n\n    public int factorial (int number) {\n        if (number <= 1){\n            return 1;\n        } else{\n            return number * factorial(number - 1);\n        }\n\n    }\n\n\n    public boolean duplicatedRandomMove(State state){\n\n        for (Node child : children) {\n            if (child.getState().equals(state)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void allChildrens(){\n\n        int desiredSize = 100;\n        int numberOfPossibleMoves = numberOfPossibleMoves();\n        System.out.println(numberOfPossibleMoves);\n        outer:\n        for (int i = 0; i < emptyCells.size(); i++) {\n\n            for (int j = i + 1; j < emptyCells.size(); j++) {\n\n                Cell c1 = emptyCells.get(i);\n                Cell c2 = emptyCells.get(j);\n                c1.setColor(0);\n                c2.setColor(1);\n                if(!this.doesContain(c1,c2))\n                    children.add(new Node(this, state, c1, c2));\n                if(!this.doesContain(c2,c1))\n                    children.add(new Node(this, state, c2, c1));\n\n                if(children.size() >= Math.min(desiredSize,numberOfPossibleMoves)){\n                    break outer;\n                }\n//                break outer;\n            }\n\n        }\n    }\n\n\n    public double winningProbability(){\n        if(numberOfSimulations > 0 )\n            return numberOfWins/(double)numberOfSimulations;\n        return 0 ;\n    }\n\n    public Node getParent() {\n        return parent;\n    }\n\n    public ArrayList<Node> getChildren() {\n        return children;\n    }\n\n    public void setChildren(ArrayList<Node> children) {\n        this.children = children;\n    }\n\n    public void setParent(Node parent) {\n        this.parent = parent;\n    }\n\n    public State getState() {return state;}\n    public void setState(State state) {this.state = state;}\n    public Node getRoot() {return root;}\n    public void setRoot(Node root) {this.root = root;}\n    public int getNumberOfSimulations() {return numberOfSimulations;}\n    public void setNumberOfSimulations(int numberOfSimulations) {this.numberOfSimulations = numberOfSimulations;}\n    public int getNumberOfWins() {return numberOfWins;}\n    public void setNumberOfWins(int numberOfWins) {this.numberOfWins = numberOfWins;}\n    public Cell getBlack() {return black;}\n    public void setBlack(Cell black) {this.black = black;}\n    public ArrayList<Cell> getEmptyCells() {return emptyCells;}\n    public void setEmptyCells(ArrayList<Cell> emptyCells) {this.emptyCells = emptyCells;}\n    public Cell getWhite() {return white;}\n    public void setWhite(Cell white) {this.white = white;}\n    public int getDepth() {return depth;}\n    public void setDepth(int depth) {this.depth = depth;}\n    public int getNumberOfChildren() {return numberOfChildren;}\n    public void setNumberOfChildren(int numberOfChildren) {this.numberOfChildren = numberOfChildren;}\n\n    public boolean doesContain(Cell white ,Cell black) {\n        for (Node node :\n                children) {\n            if (node.getWhite().getId() == white.getId() && node.getBlack().getId() == black.getId()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(parent, state, white, black, depth);\n    }\n\n    public static void main(String[] args) {\n        ArrayList<Player> players = new ArrayList<>(){};\n        players.add(new HumanPlayer(\"White\") );\n        players.add(new RandomBot(\"Black\") );\n        State state = new State(3 , players);\n\n        Cell white = state.getBoard().getCells().get(0);\n        Cell black = state.getBoard().getCells().get(1);\n        Cell black2 = state.getBoard().getCells().get(2);\n        Node node1 = new Node(null,state,white,black );\n        Node node2 = new Node(null,state,white,black );\n        System.out.println(node1.equals(node2));\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/MTS/Node.java b/src/PLAYER/MTS/Node.java
--- a/src/PLAYER/MTS/Node.java	(revision 717a4394b3d8239bfe4ee692b0aa377fd282c99f)
+++ b/src/PLAYER/MTS/Node.java	(date 1667768664444)
@@ -110,6 +110,8 @@
 
     public void allChildrens(){
 
+        //TODO FIX THIS and limit the expansion braching factor
+
         int desiredSize = 100;
         int numberOfPossibleMoves = numberOfPossibleMoves();
         System.out.println(numberOfPossibleMoves);
Index: src/PLAYER/MTS/Tree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package PLAYER.MTS;\n\nimport GAME.State;\nimport PLAYER.Player;\n\nimport java.util.ArrayList;\n\npublic class Tree {\n    Node root;\n    ArrayList<Node> nodes;\n\n    public Tree(State state){\n        root = new Node(null, state, null, null );\n    }\n\n\n    public Node selection(Node root){\n\n        Node node = root;\n        if(node.getChildren().size() == 0){\n            expansion(node);\n        }\n        while(!(node.getChildren().size() == 0)){\n            node = UCT.bestNodeUTC(node);\n        }\n\n        return node;\n    }\n\n    public void expansion(Node node){\n        node.allChildrens();\n    }\n\n    public void simulaton(Node node){\n\n        Node simNode = node;\n\n        while(!simNode.terminalNode()){\n            Node nextNode = simNode.getRandomChild();\n            if(nextNode==null){\n                expansion(simNode);\n                nextNode = simNode.getRandomChild();\n            }\n            State nextState = nextNode.getState();\n            nextNode.setState(nextState);\n//            simNode.addChild(nextNode);\n            simNode = nextNode;\n        }\n        Player winner = simNode.getState().getWinner();\n\n        int win = 0;\n\n        if(winner.isBot() && winner.getPlayerID() == 1){\n            win = 1;\n        }\n\n        simNode.setNumberOfWins(simNode.getNumberOfWins() + win);\n        simNode.setNumberOfSimulations(simNode.getNumberOfSimulations() + 1);\n\n        backpropagation(node, simNode, win);\n    }\n\n    public void backpropagation(Node node, Node simNode, int win){\n        while (!simNode.equals(node)){\n            simNode.getWhite().setColor(-1);\n            simNode.getBlack().setColor(-1);\n            Node parent = simNode.getParent();\n            parent.setNumberOfWins(simNode.getNumberOfWins() + win);\n            parent.setNumberOfSimulations(simNode.getNumberOfSimulations() + 1);\n            simNode = parent ;\n        }\n    }\n\n    public void setRoot(Node node){\n        this.root = node;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/MTS/Tree.java b/src/PLAYER/MTS/Tree.java
--- a/src/PLAYER/MTS/Tree.java	(revision 717a4394b3d8239bfe4ee692b0aa377fd282c99f)
+++ b/src/PLAYER/MTS/Tree.java	(date 1667767953912)
@@ -62,8 +62,9 @@
 
     public void backpropagation(Node node, Node simNode, int win){
         while (!simNode.equals(node)){
-            simNode.getWhite().setColor(-1);
-            simNode.getBlack().setColor(-1);
+            simNode.setState(simNode.getParent().getState());
+            //simNode.getWhite().setColor(-1);
+            //simNode.getBlack().setColor(-1);
             Node parent = simNode.getParent();
             parent.setNumberOfWins(simNode.getNumberOfWins() + win);
             parent.setNumberOfSimulations(simNode.getNumberOfSimulations() + 1);
