Index: src/GAME/Board.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package GAME;\n\nimport UI.Menu;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class Board implements Cloneable{\n    private int boardSize ;\n    private ArrayList<Cell> cells ;\n    /*\n    TODO Everyone can change these OffsetX and OffsetY values -> Run the Show class and there will be a line which gives you offset values for your screen\n         Replace the following line with the printed values on console\n     */\n    private int offsetX = 718 , offsetY = 382;\n    public Board(int boardSize){\n        this.cells = new ArrayList<>();\n        this.boardSize = boardSize;\n        createBoard();\n\n//        colorTheCellsRandomly();\n    }\n    public Board(Board board){\n        offsetX = Menu.WIDTH/2;\n        offsetY = Menu.HEIGHT/2;\n        this.boardSize = board.boardSize;\n        this.cells = new ArrayList<>();\n        createBoard();\n        copyCells(board.getCells());\n    }\n    public void copyCells(ArrayList<Cell> cells){\n        for (int i = 0; i < cells.size(); i++) {\n            this.cells.get(i).setColor(cells.get(i).getColor());\n        }\n    }\n\n    /**\n     * Colors each cell to white or black\n     * Implemented for testing purposes\n     */\n    public void colorTheCellsRandomly(){\n        for (int i = 0 ; i < cells.size()-5 ; i++) {\n            double random = Math.random();\n            if(random < 0.5 )\n                cells.get(i).setColor(0);\n            else cells.get(i).setColor(1);\n        }\n\n    }\n    /**\n     * Creates all the cells in the board , assign coordinates on GUI (x,y) and q r s and ID variables\n     */\n    private void createCells(){\n        int n = boardSize;\n        int id = 0;\n        if(cells.isEmpty()) {\n            for (int q = -n; q <= n; q++) {\n                int rMax = Math.max(-n, -q - n);\n                int rMin = Math.min(n, -q + n);\n                for (int r = rMax; r <= rMin; r++) {\n                    Cell cell = new Cell(q, r, -q - r, id++);\n                    cells.add(cell);\n                }\n            }\n        }\n    }\n\n    /**\n     * iterates over the cells in the board and creates neigborship ,( by using addNeighbor method from Cell class )\n     */\n    private void connectCells(){\n        if(cells == null){\n            createCells();\n        }\n        for (int i = 0; i < cells.size(); i++) {\n            Cell c1 = cells.get(i);\n            for (int j = 0; j < cells.size(); j++) {\n                Cell c2 = cells.get(j);\n                int abs_difference = Math.abs(c1.getQ() - c2.getQ()) + Math.abs(c1.getR() - c2.getR()) + Math.abs(c1.getS() - c2.getS());\n                if (abs_difference == 2 && i != j ) {\n                    c1.addNeighbor(c2);\n                    c2.addNeighbor(c1);\n                }\n            }\n        }\n    }\n    /**\n     * will be called by constructor to create the board\n     */\n    private void createBoard(){\n        if(this.cells == null){\n            cells = new ArrayList<>();\n        }\n        Cell.RADIUS = (int)( (offsetY*2 - 50) / (boardSize*2 + 1) / 2 );\n        createCells();\n        connectCells();\n        createCenters();\n    }\n\n    /**\n     * This method will assign the center of each hexagon on the board , x and y values\n     */\n    public void createCenters(){\n        for (Cell cell : cells) {\n            double radius = cell.getRADIUS();\n            int q = cell.getQ();\n            int r = cell.getR();\n            double sqrt3 = Math.sqrt(3);\n            double x = radius * (    3/2.d * q) +              offsetX;\n            double y = radius * (sqrt3/2.d * q  + sqrt3 * r ) +offsetY;\n\n            cell.setX(x);\n            cell.setY(y);\n        }\n    }\n\n    /**\n     * Finds the corresponding cell to x and y coordinates on screen\n     * @param x x position on screen\n     * @param y y position on screen\n     * @return a cell which is located at x and y coordinates\n     */\n    public Cell getCellFromPosition(double x , double y ){\n        double radius = cells.get(0).getRADIUS();\n        double q =    2/3.d * (x - offsetX) / radius ;\n        double r = ( -1/3.d * (x - offsetX) + Math.sqrt(3)/3 * (y - offsetY) )/ radius;\n\n        int q_i = (q >= 0 ) ? (int)  (q + 0.5) : (int)(q - 0.5) ;\n        int r_i = (r >= 0 ) ? (int)  (r + 0.5) : (int)(r - 0.5) ;\n\n        List<Cell> match = cells.stream().filter(cell -> cell.getQ() == q_i && cell.getR() == r_i).toList();\n\n        return (match.size() > 0 ) ? match.get(0) : null ;\n    }\n\n    /**\n     * iterates over the cells to check how many cells are empty\n     * @return the number of empty cells\n     */\n    public int getNumberOfEmptyCells(){\n        return cells.stream().filter(cell -> cell.getColor()==-1).toList().size();\n    }\n\n    public ArrayList<Cell> getEmptyCells(){\n        ArrayList<Cell> emptyCells= new ArrayList<>();\n        for (Cell cell :\n                cells) {\n            if(cell.isEmpty())\n                emptyCells.add(cell);\n        }\n        return emptyCells;\n    }\n    /**\n     * Calculates the score of the given color\n     * @param color is the color of the player\n     * @return the score of the given color\n     */\n    public int scoreOfAPlayer(int color ){\n        int scoreOfPlayer = multiplyTheGivenArrayList( getGroupForColor(color) );\n        setAllCellsToNotVisited();\n        return scoreOfPlayer;\n    }\n\n    public ArrayList<Integer> getGroupForColor(int color){\n        ArrayList<Integer> groups = new ArrayList<>();\n\n        for(Cell startingCell : cells ){\n            if(startingCell.getColor() == color){\n                int numberOfPiecesConnectedToStartingCell = numberOfPiecesConnectedToCell(color , startingCell);\n\n                if(numberOfPiecesConnectedToStartingCell > 0 ){ //to avoid 0 in multiplication we will have >0 or != 0 condition\n                    groups.add(numberOfPiecesConnectedToStartingCell);\n                }\n            }\n        }\n        return groups;\n    }\n\n    /**\n     * this method counts how many pieces with the given color is connected , starts to search from given cell\n     * @param color given color\n     * @param startingCell the cell which we will start searching from\n     * @return if the color doesnt match with the starting cell's color returns 0 , else returns the amount of cell with\n     * the same color is connected to the provided cell\n     */\n    public int numberOfPiecesConnectedToCell(int color,Cell startingCell){\n        if( startingCell.isVisited() && startingCell.getColor() != color )\n            return 0;\n        int number_Of_pieces_in_group = (startingCell.getColor() == color) ? 1 : 0 ;\n\n        LinkedList<Cell> queue = new LinkedList<>();\n        queue.add(startingCell);\n        startingCell.setVisited(true);\n        while(!queue.isEmpty()){\n            Cell currentCell = queue.pollLast();\n            for (Cell neighborCell :\n                    currentCell.getNeighbors()) {\n                if(!neighborCell.isVisited() && neighborCell.getColor() == color){\n                    neighborCell.setVisited(true);\n                    queue.add(neighborCell);\n                    number_Of_pieces_in_group++;\n                }\n            }\n        }\n        return number_Of_pieces_in_group;\n    }\n\n    /**\n     * multiplies all the integers in the given arrayList\n     * @param integerList an arrayList consists integers\n     * @return multiplication of elements in the provided list\n     */\n    public int multiplyTheGivenArrayList(ArrayList<Integer> integerList){\n        if(integerList.size() == 0 ) return 0;\n        int multiplication = 1 ;\n\n        for (int numberOfElementsInGroups : integerList) {\n            if( numberOfElementsInGroups != 0 ) {\n                multiplication *= numberOfElementsInGroups;\n            }\n        }\n        return multiplication;\n    }\n\n    /**\n     * sets all the visited variable of cells to False\n     */\n    public void setAllCellsToNotVisited(){\n        for (Cell cell :\n                cells) {\n            cell.setVisited(false);\n        }\n    }\n\n    public void clearBoard(){\n        for (Cell cell : cells) {\n            cell.reset();\n        }\n    }\n\n    public int getBoardSize() {\n        return boardSize;\n    }\n\n    public void setBoardSize(int boardSize) {\n        this.boardSize = boardSize;\n    }\n\n    public ArrayList<Cell> getCells() {\n        return cells;\n    }\n\n    public void setCells(ArrayList<Cell> cells) {\n        this.cells = cells;\n    }\n\n    public int getOffsetX() {\n        return offsetX;\n    }\n\n    public void setOffsetX(int offsetX) {\n        this.offsetX = offsetX;\n    }\n\n    public int getOffsetY() {\n        return offsetY;\n    }\n\n    public void setOffsetY(int offsetY) {\n        this.offsetY = offsetY;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Board)) return false;\n        Board board = (Board) o;\n\n        for (int i = 0; i < cells.size(); i++) {\n            if(cells.get(i).getColor() != board.getCells().get(i).getColor() ){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(cells);\n    }\n\n    @Override\n    public Board clone() {\n        try {\n            Board clone = (Board) super.clone();\n            // TODO: copy mutable state here, so the clone can't change the internals of the original\n            return clone;\n        } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GAME/Board.java b/src/GAME/Board.java
--- a/src/GAME/Board.java	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/src/GAME/Board.java	(date 1668096512395)
@@ -10,6 +10,7 @@
 public class Board implements Cloneable{
     private int boardSize ;
     private ArrayList<Cell> cells ;
+
     /*
     TODO Everyone can change these OffsetX and OffsetY values -> Run the Show class and there will be a line which gives you offset values for your screen
          Replace the following line with the printed values on console
@@ -36,6 +37,8 @@
         }
     }
 
+
+
     /**
      * Colors each cell to white or black
      * Implemented for testing purposes
Index: src/PLAYER/GA/GeneticAlgorithm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package PLAYER.GA;\nimport GAME.State;\nimport PLAYER.Player;\nimport PLAYER.RULE_BASED_BOT.RuleBasedBot;\nimport java.util.*;\n\npublic class GeneticAlgorithm {\n\n\n    private final int POPULATION_SIZE = 100;\n    private final int GENERATIONS = 10000;\n    private final int BOARD_SIZE = 3;\n    private final double MUTATION_RATE = 0.05;\n    private final int ADN_SIZE = 5;\n\n    private  Individuals[] population;\n    private ArrayList<Player> players = new ArrayList<>(){};\n    private final Player white = new RuleBasedBot(\"White\") ;\n    private final Player black = new RuleBasedBot(\"Black\");\n\n\n    public GeneticAlgorithm(){\n\n        players.add(white);\n        players.add(black);\n        population = generatePopulation();\n        generations(population);\n\n    }\n\n    public void generations(Individuals[] population){\n\n        for (int i = 0; i < GENERATIONS; i++) {\n            System.out.println(\"GEN \" + i);\n            population = play(population);\n            population = selection(population);\n            population = mutation(population);\n            System.out.println(population[0].toString());\n            Random rn = new Random();\n            int newFighter = rn.nextInt(POPULATION_SIZE);\n            players.get(1).setW(population[newFighter].getChromosome());\n        }\n    }\n\n    public Individuals[] play(Individuals[] population){\n\n        for (int i = 0; i < population.length; i++) {\n            State state = new State(BOARD_SIZE, players);\n            population[i].setFitness(state.getPlayers().get(0).getScore(), state.getPlayers().get(1).getScore());\n        }\n        HeapSort.sort(population);\n        return population;\n    }\n\n    public Individuals[] selection(Individuals[] population){\n\n        Random rn = new Random();\n\n        for (int i = 0; i < population.length * 0.8; i++) {\n            int i1 = rn.nextInt((int) (population.length * 0.7));\n            int i2 = rn.nextInt((int) (population.length * 0.3));\n            Individuals[] afterSex = crossover(population[i1], population[i2]);\n            population[i1] = afterSex[0];\n            population[i2] = afterSex[1];\n        }\n\n        return population;\n    }\n\n    public Individuals[] crossover(Individuals jerry, Individuals mary) {\n\n        Random rn = new Random();\n        int crossOverPoint = rn.nextInt(jerry.getChromosome().length);\n\n        double[] t = jerry.getChromosome();\n        double[] j = jerry.getChromosome();\n        double[] m = jerry.getChromosome();\n\n        for (int i = 0; i < crossOverPoint; i++) {\n            j[i] = m[i];\n            m[i] = t[i];\n        }\n        jerry.setChromosome(j);\n        mary.setChromosome(m);\n\n        return new Individuals[] {jerry, mary};\n    }\n\n    public Individuals[] mutation(Individuals[] population){\n        Random rn = new Random();\n        for (int i = 0; i < population.length * MUTATION_RATE; i++) {\n            int mutant_index = rn.nextInt(POPULATION_SIZE);\n            population[mutant_index].setChromosome(generateChomosomes());\n        }\n        return population;\n    }\n\n    public Individuals[] generatePopulation(){\n        Individuals[] population = new Individuals[POPULATION_SIZE];\n        for (int i = 0; i < POPULATION_SIZE; i++) {\n            population[i] = new Individuals(generateChomosomes());\n        }\n        return population;\n    }\n\n    public double[] generateChomosomes(){\n        double[] weight = new double[ADN_SIZE];\n        for (int i = 0; i < weight.length; i++) {\n            weight[i] = Math.random();\n        }\n        return weight;\n    }\n\n\n\n\n    public static void main(String[] args) {\n\n        GeneticAlgorithm a = new GeneticAlgorithm();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/GA/GeneticAlgorithm.java b/src/PLAYER/GA/GeneticAlgorithm.java
--- a/src/PLAYER/GA/GeneticAlgorithm.java	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/src/PLAYER/GA/GeneticAlgorithm.java	(date 1668096523468)
@@ -2,13 +2,15 @@
 import GAME.State;
 import PLAYER.Player;
 import PLAYER.RULE_BASED_BOT.RuleBasedBot;
+import PLAYER.RandomBot;
+
 import java.util.*;
 
 public class GeneticAlgorithm {
 
 
     private final int POPULATION_SIZE = 100;
-    private final int GENERATIONS = 10000;
+    private final int GENERATIONS = 1000;
     private final int BOARD_SIZE = 3;
     private final double MUTATION_RATE = 0.05;
     private final int ADN_SIZE = 5;
@@ -16,7 +18,7 @@
     private  Individuals[] population;
     private ArrayList<Player> players = new ArrayList<>(){};
     private final Player white = new RuleBasedBot("White") ;
-    private final Player black = new RuleBasedBot("Black");
+    private final Player black = new RandomBot("Black");
 
 
     public GeneticAlgorithm(){
Index: src/GAME/Clusters.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GAME/Clusters.java b/src/GAME/Clusters.java
new file mode 100644
--- /dev/null	(date 1668096956492)
+++ b/src/GAME/Clusters.java	(date 1668096956492)
@@ -0,0 +1,29 @@
+package GAME;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+public class Clusters {
+
+     ArrayList<Cell> cluster;
+     HashMap<Cell, Boolean> contains = new HashMap<>();
+
+     public Clusters(){
+          cluster = new ArrayList<>();
+     }
+
+     public void add(Cell cell){
+          cluster.add(cell);
+          contains.put(cell, true);
+     }
+
+     public static void main(String[] args) {
+          HashMap<Integer, Integer> a = new HashMap<>();
+
+          a.put(1,1);
+          a.put(1,2);
+          System.out.println(a.size());
+          System.out.println(a.get(1));
+          System.out.println(a.get(2));
+     }
+}
Index: src/UI/Menu.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package UI;\n\nimport GAME.State;\nimport PLAYER.MonteCarlo;\nimport PLAYER.HumanPlayer;\nimport PLAYER.Player;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\npublic class Menu extends JPanel{\n\n    public int boardSize = 3;\n    public final int numberOfPlayers = 2;\n    public int HumanOrComputer = 0; // default is human against human\n    public int numberOfAiPlayers = 0;\n    public JPanel panel ;\n    public Player whitePlayer =new HumanPlayer(\"White\");\n    public Player blackPlayer = new HumanPlayer(\"Black\");\n\n    private Menu(){\n        menuBoardSize();\n    }\n    //SINGLETON DESIGN PATTERN\n    //By using singleton method ,instead of creating new menus each time when we clicked on main menu button on Game Page,\n    //we can use getInstance method. which will creates the menu for the first time and returns it ,if menu is created before it will return\n    // previously created menu.\n    private static Menu menu ;\n    public static Menu getInstance() {\n        if (menu == null) {\n            menu = new Menu();\n            return menu;\n        }\n        return menu;\n    }\n\n    public JPanel getPanel() {\n        return panel;\n    }\n\n    //\n    public void menuBoardSize() {\n        //GETTING SCREEN SIZE\n        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n        int width = (int) (screenSize.getWidth() - 100);\n        int height = (int) (screenSize.getHeight() - 100);\n\n        System.out.println(\"Check the first comment in Board and replace the following line with the variables in Board class\");\n        System.out.println(\"private int offsetX = \" + width/2  +\" , \" + \"offsetY = \" + height/2 + \";\");\n\n        //LOADING BACKGROUND\n        BufferedImage originalImage = null;\n        try {\n            originalImage = ImageIO.read(new File(\"src/UI/background.jpg\"));\n        } catch (IOException ignored) {}\n        Image img = null;\n        if(originalImage != null )\n            img = originalImage.getScaledInstance( originalImage.getWidth()/3, originalImage.getHeight()/3, Image.SCALE_AREA_AVERAGING);\n        Image finalImg = img;\n\n        //SETS FRAME SIZE\n        Show.frame.setPreferredSize(new Dimension(width, height));\n\n        //CREATING PANEL\n        panel = new JPanel(){\n            @Override\n            protected void paintComponent(Graphics g) {\n                super.paintComponent(g);\n                if (finalImg != null)\n                {\n                    int x = this.getParent().getWidth()/2 - finalImg.getWidth(null)/2;\n                    int y = this.getParent().getHeight()/2 - finalImg.getHeight(null)/2;\n                    g.drawImage(finalImg,x,y,this);\n                }\n                else\n                    this.setBackground(new Color(92, 130, 117));\n        }};\n        panel.setLayout(null);\n        Show.frame.add(panel);\n\n        //LABEL BOARD SIZE\n        JLabel label_boardSize = new JLabel(\"SIZE OF THE BOARD\");\n        if(Show.customFont_50f != null) label_boardSize.setFont(Show.customFont_50f)  ;\n        label_boardSize.setForeground(Color.LIGHT_GRAY);\n        panel.add(label_boardSize);\n\n        Dimension size_l1 = label_boardSize.getPreferredSize();\n        label_boardSize.setBounds((width - size_l1.width) / 2, (height - size_l1.height) / 10 * 2, size_l1.width, size_l1.height);\n\n        //LABEL PLAYERS\n        JLabel label_Players = new JLabel(\"PLAYERS\");\n        if(Show.customFont_50f != null) label_Players.setFont(Show.customFont_50f)  ;\n        label_Players.setForeground(Color.LIGHT_GRAY);\n        panel.add(label_Players);\n\n        Dimension size_l2 = label_Players.getPreferredSize();\n        label_Players.setBounds((width - size_l2.width) / 2, (height - size_l2.height) / 10 * 5, size_l2.width, size_l2.height);\n\n\n        //BUTTONS FOR BOARD SIZE AND ACTION LISTENERS\n        JButton buttonBoardSize2 = new JButton(\"2\");\n        JButton buttonBoardSize3 = new JButton(boardSize+\"\");\n        JButton buttonBoardSize5 = new JButton(\"4\");\n        JButton buttonBoardSize7 = new JButton(\"5\");\n\n        JButton[] buttons = new JButton[]{buttonBoardSize2 , buttonBoardSize3, buttonBoardSize5, buttonBoardSize7};\n\n        for (int i = 0; i < buttons.length; i++) {\n            buttons[i].setBounds( (width - buttons.length*200-100 )/3 + 300 * i    , (height - size_l1.height) / 10 * 3, 100, 100);\n            buttons[i].setFont( Show.customFont_50f );\n            buttons[i].setOpaque(false);\n            buttons[i].setContentAreaFilled(false);\n            buttons[i].setBorderPainted(false);\n\n            if(i==0){\n                buttons[i].setForeground(Color.ORANGE);\n            }else\n                buttons[i].setForeground(Color.RED);\n\n            buttons[i].setFocusPainted(false);\n            panel.add(buttons[i]);\n            buttons[i].addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    for (JButton button: buttons ) {\n                        JButton clickedButton = (JButton) e.getSource();\n                        if(button != clickedButton){\n                            button.setForeground(Color.RED);\n                        }\n                        clickedButton.setForeground(Color.ORANGE);\n                        boardSize = Integer.parseInt(clickedButton.getText());\n                    }\n                }\n            });\n        }\n\n        //BUTTONS FOR PLAYER OPTIONS AND ACTION LISTENERS\n        JButton humanVhuman = new JButton();\n        humanVhuman.setText(\"<html><center>HUMAN<br>vs<br>HUMAN</center></html>\\n\");\n        JButton humanVcomputer = new JButton();\n        humanVcomputer.setText(\"<html><center>HUMAN<br>vs<br>COMPUTER</center></html>\\n\");\n\n\n        JButton[] buttons_player = new JButton[]{humanVhuman, humanVcomputer};\n\n        for (int i = 0; i < buttons_player.length; i++) {\n\n            buttons_player[i].setBounds( (width - 750 )/2 + 500 * i    , (height - size_l1.height) / 10 * 6, 250, 170);\n            buttons_player[i].setFont( Show.customFont_40f );\n            buttons_player[i].setOpaque(false);\n            buttons_player[i].setContentAreaFilled(false);\n            buttons_player[i].setBorderPainted(false);\n            buttons_player[i].setFocusPainted(false);\n\n            if(i==0){\n                buttons_player[i].setForeground(Color.ORANGE);\n            }else\n                buttons_player[i].setForeground(Color.RED);\n\n            panel.add(buttons_player[i]);\n            buttons_player[i].addActionListener(new ActionListener() {\n                public void actionPerformed(ActionEvent e) {\n                    for (int j = 0 ; j < buttons_player.length ; j++ ) {\n                        JButton clickedButton = (JButton) e.getSource();\n                        if(clickedButton.getText().contains(\"COMPUTER\")){\n                            blackPlayer = new MonteCarlo(\"Black\");\n                        }\n                        if (buttons_player[j] != clickedButton) {\n\n                            buttons_player[j].setForeground(Color.RED);\n                        }\n                        clickedButton.setForeground(Color.ORANGE);\n                    }\n                }\n            });\n\n        }\n\n        //PLAY BUTTON AND ACTION LISTENER\n        JButton playButton = new JButton(\"PLAY\");\n        playButton.setBounds( (width - 300 )/2     , (height - size_l1.height) / 10 * 8, 300, 80);\n\n        playButton.setFont( Show.customFont_60f );\n        playButton.setOpaque(false);\n        playButton.setContentAreaFilled(false);\n        playButton.setBorderPainted(false);\n        playButton.setForeground(Color.YELLOW);\n        playButton.setFocusPainted(false);\n        playButton.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e){\n                //Players ArrayList\n                ArrayList<Player> players = new ArrayList<>(){};\n                Player.counterForIDs = 0 ;\n                players.add(whitePlayer);\n//                players.add(new RandomBot(\"Black\") );\n                players.add(blackPlayer);\n                Grid grid = new Grid(new State(boardSize ,players ));\n                Show.frame.setContentPane(grid);\n                Show.frame.revalidate();\n\n            }\n        });\n        panel.add(playButton);\n\n        //FRAME SETTINGS and VIEW THE MENU\n        Show.frame.setTitle(\"OMEGA-5 \");\n        Show.frame.setLocation(((int) screenSize.getWidth() - width) / 2, ((int) screenSize.getHeight() - height) / 3);\n        Show.frame.setSize(width, height);\n        Show.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n        Show.frame.setVisible(true);\n    }\n\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/UI/Menu.java b/src/UI/Menu.java
--- a/src/UI/Menu.java	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/src/UI/Menu.java	(date 1668090269531)
@@ -3,6 +3,7 @@
 import GAME.State;
 import PLAYER.MonteCarlo;
 import PLAYER.HumanPlayer;
+import PLAYER.P_BOT.PBot;
 import PLAYER.Player;
 
 import javax.imageio.ImageIO;
@@ -170,6 +171,7 @@
                         JButton clickedButton = (JButton) e.getSource();
                         if(clickedButton.getText().contains("COMPUTER")){
                             blackPlayer = new MonteCarlo("Black");
+                            //blackPlayer = new PBot("Black");
                         }
                         if (buttons_player[j] != clickedButton) {
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"032db7ea-3bd4-456d-918f-7cd1c9657701\" name=\"Changes\" comment=\"sunday starting point\">\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/GA/GeneticAlgorithm.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/GA/HeapSort.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/GA/Individuals.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/Functions.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/RuleBasedBot.java\" afterDir=\"false\" />\n      <change afterPath=\"$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/Rules.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/GAME/State.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/GAME/State.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/MTS/MonteCarloTreeSearch.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/MTS/MonteCarloTreeSearch.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/MTS/Node.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/MTS/Node.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/MTS/Tree.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/MTS/Tree.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/MTS/UCT.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/MTS/UCT.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/MonteCarlo.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/MonteCarlo.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/PLAYER/Player.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/PLAYER/Player.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/UI/Grid.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/UI/Grid.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/UI/Menu.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/UI/Menu.java\" afterDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Interface\" />\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\n      <map>\n        <entry key=\"$PROJECT_DIR$\" value=\"c334b946d67c584630e4b49da2fd2670f951f275\" />\n      </map>\n    </option>\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2GzQD9zUvNJyv0AEY4cuP3UGqmG\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">\n    <property name=\"RunOnceActivity.OpenProjectViewOnStart\" value=\"true\" />\n    <property name=\"RunOnceActivity.ShowReadmeOnStart\" value=\"true\" />\n    <property name=\"SHARE_PROJECT_CONFIGURATION_FILES\" value=\"true\" />\n  </component>\n  <component name=\"RecentsManager\">\n    <key name=\"ExtractSuperBase.RECENT_KEYS\">\n      <recent name=\"PLAYER.GA\" />\n    </key>\n  </component>\n  <component name=\"RunManager\" selected=\"Application.GeneticAlgorithm\">\n    <configuration name=\"GeneticAlgorithm\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"PLAYER.GA.GeneticAlgorithm\" />\n      <module name=\"Omega\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"PLAYER.GA.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"Node\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"PLAYER.MTS.Node\" />\n      <module name=\"Omega\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"PLAYER.MTS.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"Show\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"UI.Show\" />\n      <module name=\"Omega\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"UI.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration name=\"test\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\n      <option name=\"MAIN_CLASS_NAME\" value=\"PLAYER.MTS.test\" />\n      <module name=\"Omega\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"PLAYER.MTS.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <recent_temporary>\n      <list>\n        <item itemvalue=\"Application.GeneticAlgorithm\" />\n        <item itemvalue=\"Application.Show\" />\n        <item itemvalue=\"Application.test\" />\n        <item itemvalue=\"Application.Node\" />\n        <item itemvalue=\"Application.Show\" />\n      </list>\n    </recent_temporary>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"032db7ea-3bd4-456d-918f-7cd1c9657701\" name=\"Changes\" comment=\"\" />\n      <created>1667388814892</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1667388814892</updated>\n    </task>\n    <task id=\"LOCAL-00001\" summary=\"MCST implementation first attempt :)\">\n      <created>1667396595168</created>\n      <option name=\"number\" value=\"00001\" />\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1667396595168</updated>\n    </task>\n    <task id=\"LOCAL-00002\" summary=\"methods for MTS and also I add a class UTC\">\n      <created>1667661218962</created>\n      <option name=\"number\" value=\"00002\" />\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1667661218962</updated>\n    </task>\n    <task id=\"LOCAL-00003\" summary=\"Montecarlo done will have bugs for sure idk tomorrow I will run it and fix if I can\">\n      <created>1667664036067</created>\n      <option name=\"number\" value=\"00003\" />\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1667664036067</updated>\n    </task>\n    <task id=\"LOCAL-00004\" summary=\"sunday starting point\">\n      <created>1667747042823</created>\n      <option name=\"number\" value=\"00004\" />\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\n      <option name=\"project\" value=\"LOCAL\" />\n      <updated>1667747042823</updated>\n    </task>\n    <option name=\"localTasksCounter\" value=\"5\" />\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State>\n              <option name=\"FILTERS\">\n                <map>\n                  <entry key=\"branch\">\n                    <value>\n                      <list>\n                        <option value=\"MCTS\" />\n                      </list>\n                    </value>\n                  </entry>\n                </map>\n              </option>\n            </State>\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n  <component name=\"VcsManagerConfiguration\">\n    <MESSAGE value=\"MCST implementation first attempt :)\" />\n    <MESSAGE value=\"methods for MTS and also I add a class UTC\" />\n    <MESSAGE value=\"Montecarlo done will have bugs for sure idk tomorrow I will run it and fix if I can\" />\n    <MESSAGE value=\"sunday starting point\" />\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"sunday starting point\" />\n  </component>\n  <component name=\"XDebuggerManager\">\n    <breakpoint-manager>\n      <breakpoints>\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\n          <url>file://$PROJECT_DIR$/src/PLAYER/MTS/Node.java</url>\n          <line>156</line>\n          <properties class=\"PLAYER.MTS.Node\" method=\"get_N_Children\">\n            <option name=\"EMULATED\" value=\"true\" />\n            <option name=\"WATCH_EXIT\" value=\"false\" />\n          </properties>\n          <option name=\"timeStamp\" value=\"5\" />\n        </line-breakpoint>\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\n          <url>file://$PROJECT_DIR$/src/PLAYER/MTS/Node.java</url>\n          <line>96</line>\n          <properties class=\"PLAYER.MTS.Node\" method=\"allChildren\">\n            <option name=\"EMULATED\" value=\"true\" />\n            <option name=\"WATCH_EXIT\" value=\"false\" />\n          </properties>\n          <option name=\"timeStamp\" value=\"6\" />\n        </line-breakpoint>\n      </breakpoints>\n    </breakpoint-manager>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/.idea/workspace.xml	(date 1668096726466)
@@ -1,21 +1,38 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
   <component name="ChangeListManager">
-    <list default="true" id="032db7ea-3bd4-456d-918f-7cd1c9657701" name="Changes" comment="sunday starting point">
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/GA/GeneticAlgorithm.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/GA/HeapSort.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/GA/Individuals.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/Functions.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/RuleBasedBot.java" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/src/PLAYER/RULE_BASED_BOT/Rules.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/GAME/State.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/GAME/State.java" afterDir="false" />
+    <list default="true" id="032db7ea-3bd4-456d-918f-7cd1c9657701" name="Changes" comment="GA Rulebased bot rules and functions">
+      <change afterPath="$PROJECT_DIR$/src/GAME/Clusters.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/src/PLAYER/P_BOT/PBot.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/GAME/Board.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/GAME/Board.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/GAME/Cell.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/GAME/Cell.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/GAME/State.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/GAME/State.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/GAME/TestBot.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/GAME/TestBot.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/GA/GeneticAlgorithm$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/GA/GeneticAlgorithm$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/GA/GeneticAlgorithm.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/GA/GeneticAlgorithm.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/MonteCarloTreeSearch.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/MonteCarloTreeSearch.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Node$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Node$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Node.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Node.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/ProbabilityNaive.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/ProbabilityNaive.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Tree.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/Tree.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/UCT.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/UCT.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/test.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/MTS/test.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/PLAYER/RULE_BASED_BOT/RuleBasedBot.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/PLAYER/RULE_BASED_BOT/RuleBasedBot.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Grid$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Grid$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Grid$HexListener.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Grid$HexListener.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Grid.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Grid.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Hex.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Hex.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu$2.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu$2.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu$3.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu$3.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu$4$1.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu$4$1.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu$4.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu$4.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/out/production/Omega/UI/Menu.class" beforeDir="false" afterPath="$PROJECT_DIR$/out/production/Omega/UI/Menu.class" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/GAME/Board.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/GAME/Board.java" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/PLAYER/GA/GeneticAlgorithm.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/GA/GeneticAlgorithm.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/PLAYER/MTS/MonteCarloTreeSearch.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/MTS/MonteCarloTreeSearch.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/PLAYER/MTS/Node.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/MTS/Node.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/PLAYER/MTS/Tree.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/MTS/Tree.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/PLAYER/MTS/UCT.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/MTS/UCT.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/PLAYER/MonteCarlo.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/MonteCarlo.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/PLAYER/Player.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/PLAYER/Player.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/UI/Grid.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/UI/Grid.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/UI/Menu.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/UI/Menu.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
@@ -57,7 +74,20 @@
       <recent name="PLAYER.GA" />
     </key>
   </component>
-  <component name="RunManager" selected="Application.GeneticAlgorithm">
+  <component name="RunManager" selected="Application.Clusters">
+    <configuration name="Clusters" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
+      <option name="MAIN_CLASS_NAME" value="GAME.Clusters" />
+      <module name="Omega" />
+      <extension name="coverage">
+        <pattern>
+          <option name="PATTERN" value="GAME.*" />
+          <option name="ENABLED" value="true" />
+        </pattern>
+      </extension>
+      <method v="2">
+        <option name="Make" enabled="true" />
+      </method>
+    </configuration>
     <configuration name="GeneticAlgorithm" type="Application" factoryName="Application" temporary="true" nameIsGenerated="true">
       <option name="MAIN_CLASS_NAME" value="PLAYER.GA.GeneticAlgorithm" />
       <module name="Omega" />
@@ -112,11 +142,11 @@
     </configuration>
     <recent_temporary>
       <list>
+        <item itemvalue="Application.Clusters" />
         <item itemvalue="Application.GeneticAlgorithm" />
         <item itemvalue="Application.Show" />
         <item itemvalue="Application.test" />
         <item itemvalue="Application.Node" />
-        <item itemvalue="Application.Show" />
       </list>
     </recent_temporary>
   </component>
@@ -157,7 +187,21 @@
       <option name="project" value="LOCAL" />
       <updated>1667747042823</updated>
     </task>
-    <option name="localTasksCounter" value="5" />
+    <task id="LOCAL-00005" summary="GA Rulebased bot rules and functions">
+      <created>1668014673603</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1668014673603</updated>
+    </task>
+    <task id="LOCAL-00006" summary="GA Rulebased bot rules and functions">
+      <created>1668014748641</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1668014748641</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="Vcs.Log.Tabs.Properties">
@@ -188,15 +232,16 @@
     <MESSAGE value="methods for MTS and also I add a class UTC" />
     <MESSAGE value="Montecarlo done will have bugs for sure idk tomorrow I will run it and fix if I can" />
     <MESSAGE value="sunday starting point" />
-    <option name="LAST_COMMIT_MESSAGE" value="sunday starting point" />
+    <MESSAGE value="GA Rulebased bot rules and functions" />
+    <option name="LAST_COMMIT_MESSAGE" value="GA Rulebased bot rules and functions" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
       <breakpoints>
         <line-breakpoint enabled="true" type="java-method">
           <url>file://$PROJECT_DIR$/src/PLAYER/MTS/Node.java</url>
-          <line>156</line>
-          <properties class="PLAYER.MTS.Node" method="get_N_Children">
+          <line>97</line>
+          <properties class="PLAYER.MTS.Node">
             <option name="EMULATED" value="true" />
             <option name="WATCH_EXIT" value="false" />
           </properties>
@@ -204,8 +249,8 @@
         </line-breakpoint>
         <line-breakpoint enabled="true" type="java-method">
           <url>file://$PROJECT_DIR$/src/PLAYER/MTS/Node.java</url>
-          <line>96</line>
-          <properties class="PLAYER.MTS.Node" method="allChildren">
+          <line>93</line>
+          <properties class="PLAYER.MTS.Node">
             <option name="EMULATED" value="true" />
             <option name="WATCH_EXIT" value="false" />
           </properties>
Index: src/PLAYER/MTS/Tree.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package PLAYER.MTS;\n\nimport GAME.Cell;\nimport GAME.State;\nimport PLAYER.Player;\n\nimport java.util.ArrayList;\n\npublic class Tree {\n    Node root;\n    ArrayList<Node> nodes;\n    State state ;\n    public int simNumber = 0;\n    public static int counter = 0;\n    public Tree(State state){\n        this.state = state;\n        root = new Node(null, state, null, null );\n    }\n\n\n    public Node selection(Node node){\n        Node selected ;\n        int numberOfPossible = node.numberOfPossibleMoves();\n\n        if(node.getChildren().size()>= Math.min(numberOfPossible,300)) {\n            //TODO think about the way to update the score of each node according to playerID and looking for the best or worst\n//            if(node.getPlayerID()==1)\n                selected = getBest(node);\n//            else\n//                selected = getWorst(node);\n            return selected;\n        }\n\n        //TODO implement heuristics for selection instead of random selection\n        ArrayList<Cell> emptyCells = state.getBoard().getEmptyCells();\n        Cell cell_white = emptyCells.get((int) (emptyCells.size() * Math.random()));\n        Cell cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));\n        while(cell_black.equals(cell_white))\n            cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));\n\n\n        selected = node.addChild(new Node(node,node.getState(),cell_white, cell_black));\n        return selected;\n    }\n\n    public Node getBest(Node node){\n        if(node.getChildren().size() == 0){\n            return null;\n        }\n        node = UCT.bestNodeUTC(node);\n        return node;\n    }\n\n    public Node getWorst(Node node){\n        if(node.getChildren().size() == 0){\n            return null;\n        }\n        node = UCT.worstNodeUTC(node);\n        return node;\n    }\n\n    public void simulation(Node node){\n        simNumber=counter++;\n        Node tempRoot = node;\n        while(!state.isGameOver()){\n            Node nextNode = selection(node);\n            nextNode.color();\n\n\n            nextNode.getState().updatePlayerScores();\n            //TODO we need to save players score to corresponding cell after each move in this way while backtracking we wont have to calculate it again and again\n            node =nextNode;\n        }\n        //TODO we may need to calculate method after each move\n        //TODO centerOfMass of Clusters()\n        Player winner = node.getState().getWinner();\n        Player loser = node.getState().getLoser();\n\n        double win = 0;\n        int winnerId = 0;\n\n        if(winner == null || loser==null){\n            win = 0.5;\n            winnerId = -1;\n        }else if(winner.getPlayerID() == 1){\n            win = 1;\n            winnerId=1;\n        }\n\n        node.setNumberOfWins(node.getNumberOfWins() + win);\n        node.setNumberOfSimulations(node.getNumberOfSimulations() + 1);\n\n        backpropagation(tempRoot, node, win,winnerId);\n    }\n    public void backpropagation(Node root, Node node, double win , int winnerId){\n        while (!node.equals(root) ){\n            Node parent = node.getParent();\n            parent.setNumberOfSimulations(parent.getNumberOfSimulations() + 1);\n            if(winnerId == -1)\n                parent.setNumberOfWins(parent.getNumberOfWins()+win);\n            //TODO Think and research about updating score for each parent node by taking playerId of the parent !!!!! It may effect to look for the best or the worst score !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n            else if(parent.getPlayerID()==winnerId)\n                parent.setNumberOfWins(parent.getNumberOfWins() + win);\n\n            node.uncolor();\n            //TODO assign the scores according to saved scores\n            node = parent;\n        }\n\n    }\n\n    public void setRoot(Node node){\n        this.root = node;\n        //TODO after assigning the root an existing node , we may want to set the pieces to null\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/MTS/Tree.java b/src/PLAYER/MTS/Tree.java
--- a/src/PLAYER/MTS/Tree.java	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/src/PLAYER/MTS/Tree.java	(date 1668020997346)
@@ -3,6 +3,7 @@
 import GAME.Cell;
 import GAME.State;
 import PLAYER.Player;
+import PLAYER.RULE_BASED_BOT.RuleBasedBot;
 
 import java.util.ArrayList;
 
@@ -17,6 +18,7 @@
         root = new Node(null, state, null, null );
     }
 
+    RuleBasedBot heuristic = new RuleBasedBot("Black");
 
     public Node selection(Node node){
         Node selected ;
@@ -33,10 +35,13 @@
 
         //TODO implement heuristics for selection instead of random selection
         ArrayList<Cell> emptyCells = state.getBoard().getEmptyCells();
-        Cell cell_white = emptyCells.get((int) (emptyCells.size() * Math.random()));
-        Cell cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));
+        //Cell cell_white = emptyCells.get((int) (emptyCells.size() * Math.random()));
+        //Cell cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));
+        Cell cell_white = heuristic.getMoves(node.getState()).get(0);
+        Cell cell_black = heuristic.getMoves(node.getState()).get(1);
         while(cell_black.equals(cell_white))
-            cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));
+            cell_black = heuristic.getMoves(node.getState()).get(1);
+            //cell_black = emptyCells.get((int) (emptyCells.size() * Math.random()));
 
 
         selected = node.addChild(new Node(node,node.getState(),cell_white, cell_black));
Index: src/PLAYER/MTS/MonteCarloTreeSearch.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package PLAYER.MTS;\n\nimport GAME.Cell;\nimport GAME.State;\n\nimport java.util.ArrayList;\n\npublic class MonteCarloTreeSearch {\n\n    private final double SEARCH_TIME = 30000;\n    Tree tree;\n    public MonteCarloTreeSearch(State state){\n        this.tree = new Tree(state);\n    }\n\n    public ArrayList<Cell> bestMove(State state){\n        ArrayList<Cell> move = new ArrayList<>();\n        //TODO instead of creating a new tree all the time, check that if it is discovered before if yes use it wisely otherwise create a new tree!\n        this.tree = new Tree(state);\n        double a = 0;\n\n        while ( a < SEARCH_TIME){\n            double start = System.currentTimeMillis();\n\n            Node currentNode = tree.root;\n            tree.simulation(currentNode);\n\n            double finish = System.currentTimeMillis();\n            a += finish-start;\n        }\n\n        Node winner = tree.getBest(tree.root);\n//        System.out.println(\"UCT : \" + UCT.UCT(winner.getParent().getNumberOfSimulations(),winner.getNumberOfWins(),winner.getNumberOfSimulations()));\n        System.out.println(\"wins : \" +  winner.getNumberOfWins() + \" sims: \" + winner.getNumberOfSimulations());\n        System.out.println(tree.simNumber);\n        move.add(winner.getWhite());\n        move.add(winner.getBlack());\n        return move;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/MTS/MonteCarloTreeSearch.java b/src/PLAYER/MTS/MonteCarloTreeSearch.java
--- a/src/PLAYER/MTS/MonteCarloTreeSearch.java	(revision b13491148ba221459ef2cb0e98f3d1e8e4f2b3c9)
+++ b/src/PLAYER/MTS/MonteCarloTreeSearch.java	(date 1668020771596)
@@ -2,16 +2,18 @@
 
 import GAME.Cell;
 import GAME.State;
+import PLAYER.Player;
+import PLAYER.RULE_BASED_BOT.RuleBasedBot;
 
 import java.util.ArrayList;
 
 public class MonteCarloTreeSearch {
 
-    private final double SEARCH_TIME = 30000;
+
+    private final double SEARCH_TIME = 3000;
     Tree tree;
-    public MonteCarloTreeSearch(State state){
-        this.tree = new Tree(state);
-    }
+
+    public MonteCarloTreeSearch(State state){this.tree = new Tree(state);}
 
     public ArrayList<Cell> bestMove(State state){
         ArrayList<Cell> move = new ArrayList<>();
Index: src/PLAYER/P_BOT/PBot.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/PLAYER/P_BOT/PBot.java b/src/PLAYER/P_BOT/PBot.java
new file mode 100644
--- /dev/null	(date 1668022702670)
+++ b/src/PLAYER/P_BOT/PBot.java	(date 1668022702670)
@@ -0,0 +1,45 @@
+package PLAYER.P_BOT;
+
+import GAME.Cell;
+import GAME.State;
+import PLAYER.Player;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+
+public class PBot extends Player {
+
+    public PBot(String playerName){
+        this.playerName = playerName;
+        this.playerID = counterForIDs % 2;
+        counterForIDs++;
+    }
+    @Override
+    public boolean isBot() {
+        return true;
+    }
+
+    ArrayList<Integer> value = new ArrayList<>();
+    HashMap<Integer, Cell> hashMap= new HashMap<>();
+
+    public ArrayList<Cell> getMoves(State state){
+        ArrayList<Cell> move = new ArrayList<>();
+        ArrayList<Cell> emptyCells = state.getBoard().getEmptyCells();
+
+        for (int i = 0; i < emptyCells.size(); i++) {
+            emptyCells.get(i).setColor(0);
+            value.add(state.getBoard().scoreOfAPlayer(0));
+            hashMap.put(state.getBoard().scoreOfAPlayer(0), emptyCells.get(i));
+            emptyCells.get(i).setColor(1);
+            value.add(state.getBoard().scoreOfAPlayer(1));
+            hashMap.put(state.getBoard().scoreOfAPlayer(0), emptyCells.get(i));
+            emptyCells.get(i).setColor(-1);
+        }
+
+        move.add(hashMap.get(Collections.min(value)));
+        move.add(hashMap.get(Collections.max(value)));
+
+        return move;
+    };
+}
